import os
import sqlparse
from bokeh.io import show
from bokeh.models import Plot, Range1d, Circle, MultiLine, HoverTool, ColumnDataSource, GraphRenderer, StaticLayoutProvider
from bokeh.plotting import figure
from bokeh.palettes import Spectral4
import networkx as nx


def clean_and_format_sql(file_path):
    """
    Cleans and formats the SQL file to remove comments and unnecessary whitespaces.
    """
    if os.path.exists(file_path):
        with open(file_path, "r") as sql_file:
            sql = sql_file.read()

        # Clean and format SQL
        formatted_sql = sqlparse.format(
            sql,
            strip_comments=True,
            strip_whitespace=True,
            reindent=True,
            keyword_case="upper",
        )
        return formatted_sql
    else:
        raise FileNotFoundError(f"File not found: {file_path}")


def parse_sql(file_path):
    """
    Parses the cleaned SQL file to extract tables, join types, and conditions.
    """
    sql = clean_and_format_sql(file_path)
    lines = sql.splitlines()

    tables = []  # To store table names
    joins = []   # To store join types and conditions
    lineage_graph = {}

    for line in lines:
        tokens = line.strip().split()
        if not tokens:
            continue

        # Extract tables from FROM clause
        if "FROM" in tokens:
            try:
                table_name = tokens[tokens.index("FROM") + 1].strip(",")
                tables.append(table_name)
                if "FROM" not in lineage_graph:
                    lineage_graph["FROM"] = []
                lineage_graph["FROM"].append(table_name)
            except IndexError:
                pass

        # Extract tables, join types, and conditions from JOIN clause
        if "JOIN" in tokens:
            try:
                table_name = tokens[tokens.index("JOIN") + 1].strip(",")
                join_type = " ".join(tokens[:tokens.index("JOIN")]).strip() or "INNER"
                condition_index = tokens.index("ON") + 1 if "ON" in tokens else None
                condition = tokens[condition_index:] if condition_index else []
                joins.append({"table": table_name, "type": join_type, "condition": " ".join(condition)})
                if "JOIN" not in lineage_graph:
                    lineage_graph["JOIN"] = []
                lineage_graph["JOIN"].append({"table": table_name, "type": join_type, "condition": " ".join(condition)})
            except IndexError:
                pass

    return lineage_graph


def visualize_data_lineage_with_bokeh(lineage_graph):
    """
    Visualizes the data lineage using Bokeh.
    """
    # Create a directed graph
    G = nx.DiGraph()

    # Add nodes and edges to the graph
    for key, values in lineage_graph.items():
        if key == "FROM":
            for value in values:
                G.add_edge("QUERY", value)
        elif key == "JOIN":
            for join in values:
                G.add_edge(join["table"], f"{join['type']} JOIN")
                G.add_edge(f"{join['type']} JOIN", "QUERY")

    # Convert the graph into Bokeh's GraphRenderer
    graph_renderer = GraphRenderer()

    # Create node index mapping
    node_indices = list(G.nodes())
    graph_renderer.node_renderer.data_source.add(node_indices, 'index')
    graph_renderer.node_renderer.data_source.add(
        [Spectral4[i % 4] for i in range(len(node_indices))], 'color'
    )
    graph_renderer.node_renderer.glyph = Circle(size=15, fill_color="color")

    # Define edges
    start_indices = [list(G.nodes()).index(edge[0]) for edge in G.edges()]
    end_indices = [list(G.nodes()).index(edge[1]) for edge in G.edges()]
    graph_renderer.edge_renderer.data_source.data = dict(start=start_indices, end=end_indices)
    graph_renderer.edge_renderer.glyph = MultiLine(line_color="black", line_alpha=0.8, line_width=1)

    # Define layout
    layout = nx.spring_layout(G)
    graph_renderer.layout_provider = StaticLayoutProvider(graph_layout=layout)

    # Create Bokeh plot
    plot = Plot(
        x_range=Range1d(-1.1, 1.1),
        y_range=Range1d(-1.1, 1.1),
        title="SQL Data Lineage Visualization",
        width=800,
        height=600
    )
    plot.add_tools(HoverTool(tooltips=[("Node", "@index")]))
    plot.renderers.append(graph_renderer)

    # Show the plot
    show(plot)


# Example usage
if __name__ == "__main__":
    # Provide the path to your SQL file
    sql_file_path = "path_to_your_sql_file.sql"

    try:
        lineage_graph = parse_sql(sql_file_path)
        print("Lineage Graph:", lineage_graph)
        visualize_data_lineage_with_bokeh(lineage_graph)
    except Exception as e:
        print(f"Error: {e}")
