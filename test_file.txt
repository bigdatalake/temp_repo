import os
import sqlparse
from sqlparse.sql import Identifier, IdentifierList, TokenList
from sqlparse.tokens import Keyword, DML
from graphviz import Digraph

def extract_table_name(token):
    """
    Extracts table name from a token.
    """
    if isinstance(token, Identifier):
        return token.get_real_name()
    elif isinstance(token, IdentifierList):
        return [identifier.get_real_name() for identifier in token.get_identifiers()]
    return None

def ParseSql(filePath):
    """
    Parses an SQL file to extract detailed data lineage.
    """
    if not os.path.exists(filePath):
        raise FileNotFoundError(f"File not found: {filePath}")
    
    with open(filePath, "r") as sql_file:
        sql = sql_file.read()
    
    formatted_sql = sqlparse.format(sql, strip_comments=True, keyword_case='upper')
    parsed = sqlparse.parse(formatted_sql)

    lineage = {
        "tables": set(),
        "relationships": [],  # JOIN relationships with types
        "where_clause": None,
        "group_by_clause": None,
        "having_clause": None,
        "union": False,
    }

    for statement in parsed:
        tokens = [token for token in statement.flatten() if not token.is_whitespace]
        for i, token in enumerate(tokens):
            token_value = token.value.upper()

            if token.ttype is DML and token_value == "SELECT":
                continue

            elif token.ttype is Keyword and token_value == "FROM":
                next_token = tokens[i + 1] if i + 1 < len(tokens) else None
                table_name = extract_table_name(next_token)
                if table_name:
                    lineage["tables"].update(table_name if isinstance(table_name, list) else [table_name])

            elif token.ttype is Keyword and "JOIN" in token_value:
                join_type = token_value.replace("JOIN", "").strip() or "INNER"
                next_token = tokens[i + 1] if i + 1 < len(tokens) else None
                table_name = extract_table_name(next_token)
                if table_name:
                    lineage["relationships"].append({
                        "type": join_type.upper(),
                        "table": table_name
                    })

            elif token.ttype is Keyword and token_value == "WHERE":
                where_tokens = tokens[i + 1:]
                lineage["where_clause"] = " ".join(t.value for t in where_tokens)

            elif token.ttype is Keyword and token_value == "GROUP BY":
                group_by_tokens = tokens[i + 1:]
                lineage["group_by_clause"] = " ".join(t.value for t in group_by_tokens)

            elif token.ttype is Keyword and token_value == "HAVING":
                having_tokens = tokens[i + 1:]
                lineage["having_clause"] = " ".join(t.value for t in having_tokens)

            elif token.ttype is Keyword and token_value == "UNION":
                lineage["union"] = True

    lineage["tables"] = list(lineage["tables"])
    return lineage

def visualize_lineage(lineage):
    """
    Visualizes the SQL lineage using Graphviz.
    
    Args:
    - lineage (dict): Lineage dictionary containing tables, relationships, and clauses.
    """
    graph = Digraph("SQL_Lineage", format="png", node_attr={'shape': 'box', 'style': 'rounded'})

    # Add tables as nodes
    for table in lineage["tables"]:
        graph.node(table, table)

    # Add relationships as edges
    for rel in lineage["relationships"]:
        graph.edge("Main Query", rel["table"], label=f"{rel['type']} JOIN")

    # Add additional information as subgraphs or labels
    if lineage["where_clause"]:
        graph.node("WHERE", f"WHERE:\n{lineage['where_clause']}", shape="note")
        graph.edge("Main Query", "WHERE")
    if lineage["group_by_clause"]:
        graph.node("GROUP BY", f"GROUP BY:\n{lineage['group_by_clause']}", shape="note")
        graph.edge("WHERE", "GROUP BY")
    if lineage["having_clause"]:
        graph.node("HAVING", f"HAVING:\n{lineage['having_clause']}", shape="note")
        graph.edge("GROUP BY", "HAVING")
    if lineage["union"]:
        graph.node("UNION", "UNION", shape="note")
        graph.edge("HAVING", "UNION")

    # Save and render the graph
    graph.render("sql_lineage_graph", view=True)

if __name__ == "__main__":
    # Sample SQL file path
    sql_file_path = "sample.sql"  # Replace with the actual SQL file path

    try:
        lineage = ParseSql(sql_file_path)
        print("Data Lineage:", lineage)
        visualize_lineage(lineage)
    except FileNotFoundError as e:
        print(e)
